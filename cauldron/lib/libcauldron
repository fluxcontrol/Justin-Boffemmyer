#!/bin/bash
#-------------------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
##  libcauldron is a set of functions used internally by the cauldron script
##
##=head1 COPYRIGHT
##
##  Copyright 2009 by the Cauldron Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#-------------------------------------------------------------------------------

# set LC_COLLATE to C so we don't get affected by the user's locale
# when grepping, sorting, etc.
export LC_COLLATE="C"

# shorthand and non-hardcoded /dev/null for output dumping
CAULDRON_NULL="${CAULDRON_NULL:-/dev/null}"

#-------------------------------------------------------------------------------
##
## Used only when checking initialization of the library and a fatal error
## occurs. Afterwards, functions from liberror are used instead.
##
#-------------------------------------------------------------------------------
function cauldron_fatal_error() {
  echo "$1"
  exit 1
}

#-------------------------------------------------------------------------------
##
## error handling library includes - load these first!
##
#-------------------------------------------------------------------------------
. "$CAULDRON_COMMON/liberror" 2>"$CAULDRON_NULL" ||
  cauldron_fatal_error "error: cannot load base library liberror"

# load cauldron error code and message defines
. "$CAULDRON_LIBS/errorcodes" 2>"$CAULDRON_NULL" ||
  cauldron_fatal_error "error: cannot load cauldron error codes"

. "$CAULDRON_COMMON/libcolor" 2>"$CAULDRON_NULL" ||
  cauldron_fatal_error "error: cannot load base library libcolor"

# test/set whether color output should be enabled
[[ $CAULDRON_COLOR != "yes" ]] && LIBCOLOR_NOCOLOR="yes"

# drop cauldron_fatal_error if liberror was successfully loaded
unset cauldron_fatal_error

#-------------------------------------------------------------------------------
## @param library name to load (no path, just basename)
##
## Loads the library given as the first argument. liberror_check_fatal is
## called to check if there was a problem loading the library, and if there was
## it will print a corresponding error message and then exit with the error
## $ERR_LOAD_LIBRARY.
##
#-------------------------------------------------------------------------------
function cauldron_load_library() {
  local lib="$1"

  . "$CAULDRON_LIBS/$lib" 2>$CAULDRON_NULL
  liberror_check_fatal "cannot load library $lib"
}

#-------------------------------------------------------------------------------
# cauldron includes
#-------------------------------------------------------------------------------
cauldron_load_library "lib.sorcerous"
cauldron_load_library "lib.chroot"
cauldron_load_library "lib.init"
cauldron_load_library "lib.toolchain"

#-------------------------------------------------------------------------------
## @param color state [yes or no] (optional)
##
## Wrapper function that handles setting the color state in libcolor. Possible
## values for the color state parameter are 'yes' or 'no' (without the quotes).
## If the parameter isn't supplied, then it defaults to whatever CAULDRON_COLOR
## is set to.
##
#-------------------------------------------------------------------------------
function cauldron_color() {
  local color="${1:-$CAULDRON_COLOR}"

  [ "$1" = "no" ] && LIBCOLOR_NOCOLOR="yes"
}

#-------------------------------------------------------------------------------
## @param messages
##
## Prints informational messages to the console, but only if CAULDRON_VERBOSE
## is enabled.
##
#-------------------------------------------------------------------------------
function cauldron_verbose() {
  [[ "$CAULDRON_VERBOSE" == "yes" ]] &&
    libcolor_msg notice "$@"
}

#-------------------------------------------------------------------------------
## @param messages
##
## Prints error messages to the console, but only if CAULDRON_VERBOSE is
## enabled.
##
#-------------------------------------------------------------------------------
function cauldron_verbose_error() {
  [[ "$CAULDRON_VERBOSE" == "yes" ]] &&
    libcolor_msg error "$@"
}

#-------------------------------------------------------------------------------
## @param VARIABLE
##
## Prints the current value of the specified VARIABLE. If VARIABLE is an array,
## it returns the full array as a single string.
##
#-------------------------------------------------------------------------------
function cauldron_get_variable() {
  for var in "$@"
  do
    [[ -n "$var" ]] || return $ERR_TARGET

    var=$(declare -p "$var")
    printf "%s\n" "${var##*$1=}"
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
## @param cleanfile
##
## Cleans out unneeded files that were used to generate the ISO, but should
## not be present on the final ISO system. cleanfile is a file that lists paths
## to remove (absolute paths, relative to a chroot of the iso), one file/path
## per line.
##
#-------------------------------------------------------------------------------
function cauldron_clean_iso_system() {
  local cleanfile="$1"

  [[ -z "$cleanfile" ]] && return $ERR_CLEAN_FILE

  cauldron_chroot_current -q || return $ERR_CHROOT_CURRENT

  for i in $(sort -r $cleanfile)
  do
    if [[ -d "$i" ]]
    then
      "$CAULDRON_CMD_OUTPUT[@]}" "Attempting to remove directory $i..."
      cauldron_chroot rmdir "$i" || return $ERR_CLEAN_DIR
    else
      "$CAULDRON_CMD_OUTPUT[@]}" "Deleting $i"
      cauldron_chroot rm "$i" || return $ERR_CLEAN_FILE
    fi
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
## @param target chroot directory
##
## Ensures the existence of basic FHS directories, dev nodes, etc. in the target
## chroot directory. If the target chroot parameter isn't given, it defaults to
## CAULDRON_BUILD.
##
#-------------------------------------------------------------------------------
function cauldron_fs_bootstrap() {
  local target="${1:-$CAULDRON_BUILD}"
  local dir=

  [[ -d "$target" ]] || return $ERR_TARGET

  # guarantee the existence of necessary basic directories
  for dir in "${CAULDRON_FHS_DIRS[@]}"
  do
    cauldron_verbose "Attempting mkdir $target/$dir ..."

    "${CAULDRON_CMD_MKDIR[@]}" "$target/$dir"
    liberror_check "$target/$dir" || return $ERR_MK_DIR
  done
  for dir in tmp var/tmp
  do
    "${CAULDRON_CMD_CHMOD[@]}" 1777 "$target/$dir"
    liberror_check "$target/$dir" || return $ERR_CHMOD_FILE
  done
  "${CAULDRON_CMD_CHMOD[@]}" 0750 "$target/root"
  liberror_check "$target/root" || return $ERR_CHMOD_FILE

  cauldron_chroot_init "$target"
  liberror_check || return $?

  # run ldconfig in the target to ensure proper library links
  (
    # set _everything_ in locale to "C" first
    export LANG=C
    export LC_ALL=C
    cauldron_chroot ldconfig
  )
  liberror_check || return $ERR_LDCONFIG

  # guarantee that static dev nodes exist in /dev in the chroot
  echo 'cd /dev && /sbin/MAKEDEV generic' > "$target/tmp/makedevs"
  liberror_check "$target/tmp/makedevs" || return $ERR_MK_FILE
  cauldron_chroot sh "/tmp/makedevs"
  liberror_check || return $?
  cauldron_chroot rm "/tmp/makedevs"
  liberror_check || return $?

  # guarantee the existence of /dev/initctl in the chroot
  cauldron_chroot mkfifo -m 0660 "/dev/initctl"
  liberror_check || return $?

  cauldron_chroot_done "$target"
  liberror_check || return $?

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Packages the sys directory into a compressed tarball to be placed in the iso
## filesystem as system.tar.bz2. Relies on the fact that
## CAULDRON_CMD_ARCHIVE_SYS will add a file suffix to the CAULDRON_SYS_NAME
## base filename.
##
#-------------------------------------------------------------------------------
function cauldron_package_sys() {
  "${CAULDRON_CMD_ARCHIVE_SYS[@]}" || return $ERR_SYS_PACKAGE

  "${CAULDRON_CMD_COMPRESS[@]}" "$CAULDRON_BUILD/$CAULDRON_SYS_NAME".* ||
    return $ERR_SYS_COMPRESS

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Builds the ISO filesystem using the generated ISO data and the filename
## set in the cauldron config file.
##
#-------------------------------------------------------------------------------
function cauldron_package_iso() {
  "${CAULDRON_CMD_MKISO[@]}" || return $ERR_ISO_PACKAGE

  "${CAULDRON_CMD_COMPRESS[@]}" "$CAULDRON_ISO_NAME" || return $ERR_ISO_COMPRESS

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Sources the enchantment config files in the build chroot so that we can
## obtain (and modify if the user so wishes) the paths where we will store the
## enchantment files (libraries, installers, install modules, etc.) on the ISO.
##
#-------------------------------------------------------------------------------
function cauldron_source_enchantment() {
  local host_enchant_config="$CAULDRON_HOST/etc/cauldron/enchantment/config"
  local enchant_config="$CAULDRON_BUILD/etc/enchantment/config"
  local enchant_lconfig="$CAULDRON_BUILD/etc/enchantment/local/config"

  # make sure the ISO has the enchantment configs first
  # if, we need to copy them (they are required for the ISO)
  if [[ ! -f "$enchant_config" ]]
  then
    "${CAULDRON_CMD_CP_FORCE[@]}" "$host_enchant_config" "$enchant_config" ||
      liberror_die $ERR_ENCHANT_CONFIG
  fi

  # set ENCHANT_ISO_PATH before sourcing the enchantment configs so all the
  # enchantment variables used by cauldron will be relative to the cauldron
  # build chroot
  ENCHANT_ISO_PATH="$CAULDRON_BUILD"

  # source the enchantment config to make sure we get the paths correct
  . "$enchant_config" 2>$CAULDRON_NULL ||
    liberror_die $ERR_ENCHANT_CONFIG
  # try to source the local config, but don't die if it doesn't exist
  . "$enchant_lconfig" 2>$CAULDRON_NULL
}

#-------------------------------------------------------------------------------
##
## Adds the given installer(s) listed in $CAULDRON_INSTALLERS to the ISO system.
## The user can then choose the installer either at boot-time or run-time.
##
## The installer(s) can currently be shell or menu (future: X?). In theory it
## should support any installer, as long as it's packaged in its own directory
## and the name of that dir is included in CAULDRON_INSTALLERS, and the binary
## to execute for that installer is named enchantment* (i.e., enchantment
## (shell) or enchantment-menu). This behavior may change in the future though.
##
#-------------------------------------------------------------------------------
function cauldron_add_installers() {
  local installer=""

  # no need to return error if cauldron_source_enchantment fails, because it
  # runs liberror_die itself on error, which causes an exit
  [[ -z $ENCHANT_DATA ]] && cauldron_source_enchantment

  # make sure CAULDRON_BUILD/ENCHANT_DATA exists
  "${CAULDRON_CMD_MKDIR[@]}" "$ENCHANT_DATA" || return $ERR_INSTALLER_DIR

  for installer in $CAULDRON_INSTALLERS
  do
    "${CAULDRON_CMD_CP_RECURSE[@]}" \
      "$CAULDRON_LIBS/enchantment/$installer" \
      "$ENCHANT_DATA/" ||
        return $ERR_COPY_INSTALLER
    "$CAULDRON_CMD_SYMLINK_FORCE[@]}" \
      "$ENCHANT_DATA/$installer"/bin/enchantment* \
      "$CAULDRON_BUILD/usr/sbin/" ||
        return $ERR_LINK_INSTALLER
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## This prepares the CAULDRON_BUILD directory for cauldron work by copying
## sorcery and cauldron files into it. It also configures the CAULDRON_BUILD
## sorcery as necessary (i.e. ensures that CLEAN_SOURCE="off"), as well as
## adding grimoires.
##
#-------------------------------------------------------------------------------
function cauldron_prepare() {
  local target="${1:-$CAULDRON_BUILD}"

  # ensure that the build dir exists
  [[ -d "$target" ]] || "${CAULDRON_CMD_MKDIR[@]}" "$target"
  liberror_check || return $?

  # ensure necessary directories exist in the CAULDRON_BUILD chroot
  for dir in "${CAULDRON_FHS_DIRS[@]}"
  do
    if [[ ! -d "$target/$dir" ]]
    then
      "${CAULDRON_CMD_MKDIR[@]}" "$target/$dir"
      liberror_check || return $?
    fi
  done

  # copy the host's resolv.conf in order to dl sources from the net
  "${CAULDRON_CMD_CP[@]}" \
    "$CAULDRON_RESOLV" \
    "$CAULDRON_BUILD/etc/resolv.conf"
  liberror_check || return $ERR_RESOLV

  # prepare chroots to target, used in turn by functions called below
  cauldron_chroot_init "$target"
  liberror_check || return $?

  if ! declare -lF cauldron_sorcerous_install
  then
    cauldron_load_library lib.sorcerous
  fi

  # install sorcery into the build dir
  cauldron_sorcerous_download
  liberror_check || return $?
  cauldron_sorcerous_install
  liberror_check || return $?

  # clean up the chroot
  cauldron_chroot_done "$target"
  liberror_check || return $?

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Cleans up the tmp directories and such forth
##
#-------------------------------------------------------------------------------
function cauldron_cleanup() {
  # if the user wants everything cleaned, kill the build directory
  if [[ "$CAULDRON_CLEAN" == "yes" ]]
  then
    "${CAULDRON_CMD_RM_RECURSE_FORCE[@]}" "$CAULDRON_BUILD" ||
      return $ERR_CLEANUP_BUILD
  fi

  # kill the temp directory
  "${CAULDRON_CMD_RM_RECURSE_FORCE[@]}" "$CAULDRON_TMP" || return $ERR_CLEANUP_TMP

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#-------------------------------------------------------------------------------

# vim:ai:tw=80:tabstop=2:softtabstop=2:shiftwidth=2:expandtab
